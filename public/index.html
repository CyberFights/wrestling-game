<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Wrestling Creator — Body-first Builder</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial; margin:16px; max-width:1300px; }
    h1 { margin-bottom:8px; }
    .layout { display:flex; gap:16px; align-items:flex-start; }
    .left { flex:1; }
    .right { width:520px; }
    .card { border:1px solid #e6e7eb; border-radius:8px; padding:12px; margin-bottom:12px; background:#fff; }
    .thumb-grid { display:flex; gap:8px; flex-wrap:wrap; }
    .thumb { width:120px; height:160px; border:1px solid #e6e7eb; border-radius:6px; padding:6px; display:flex; flex-direction:column; align-items:center; justify-content:center; background:white; cursor:pointer; user-select:none; }
    .thumb img { max-width:100%; max-height:110px; object-fit:cover; border-radius:4px; }
    .small { font-size:12px; color:#6b7280; }
    .avatar-stage { position:relative; width:420px; height:630px; background:#fff; border:1px solid #ddd; border-radius:6px; overflow:hidden; margin:8px auto; }
    .avatar-layer { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }
    .layered { position:absolute; transform-origin:center center; pointer-events:auto; will-change:transform,left,top; }
    .controls { display:flex; gap:8px; justify-content:center; margin-top:8px; }
    .accessory-pill { display:flex; align-items:center; gap:6px; padding:4px 6px; border-radius:6px; border:1px solid #e6e7eb; background:#fff; }
    .dialog { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); background:#fff; border:1px solid #d1d5db; padding:12px; border-radius:8px; z-index:9999; box-shadow:0 6px 24px rgba(15,23,42,0.15); }
    .overlay { position:fixed; inset:0; background:rgba(0,0,0,0.35); z-index:9998; }
    input[type="range"] { width:200px; }
    label { font-size:13px; display:block; margin-bottom:4px; }
    select { padding:8px; border-radius:6px; border:1px solid #d1d5db; }
    .btn { padding:8px 10px; border-radius:6px; border:1px solid #d1d5db; background:#fff; cursor:pointer; }
    .btn.primary { background:#2563eb; color:#fff; border-color:transparent; }
    .anchor-dot { position:absolute; width:10px; height:10px; border-radius:50%; background:rgba(37,99,235,0.9); transform:translate(-50%,-50%); pointer-events:none; }
  </style>
</head>
<body>
  <h1>Wrestling Creator — Body-first Builder</h1>

  <div class="card">
    <div style="display:flex; gap:12px; align-items:center;">
      <input id="name" placeholder="Wrestler name" style="flex:1;padding:8px;border:1px solid #e5e7eb;border-radius:6px" />
      <button id="saveBtn" class="btn primary">Save</button>
    </div>
    <div class="small" style="margin-top:6px">Select a body (size + skin) first. Then choose height — clothing will auto-resize to match the selected body proportions.</div>
  </div>

  <div class="layout">
    <div class="left">
      <div class="card">
        <div class="small" style="margin-bottom:8px">1) Choose Body Type (size + skin variants)</div>
        <div id="bodyTypes" class="thumb-grid"></div>
      </div>

      <div class="card">
        <div class="small" style="margin-bottom:8px">2) Height — changes vertical scale while keeping width proportionate for the selected body type</div>
        <label for="heightSelect">Preset heights</label>
        <select id="heightSelect">
          <option value="short">Short</option>
          <option value="average" selected>Average</option>
          <option value="tall">Tall</option>
        </select>

        <label style="margin-top:8px">Fine height adjustment</label>
        <input id="heightRange" type="range" min="80" max="120" value="100" />
        <div class="small" id="heightValue">Height scale: 100%</div>
      </div>

      <div class="card">
        <div class="small">3) Customization (enabled after body chosen)</div>
        <div style="margin-top:8px">
          <div id="attires" class="thumb-grid"></div>
          <div id="masks" class="thumb-grid" style="margin-top:8px"></div>
          <div id="accessories" class="thumb-grid" style="margin-top:8px"></div>
        </div>
      </div>

      <div class="card">
        <div class="small">Accessory Tray (equipped)</div>
        <div id="accessoryTray" style="display:flex;gap:6px;flex-wrap:wrap;padding:8px;border:1px dashed #e6e7eb;border-radius:8px;min-height:48px;margin-top:8px"></div>
      </div>
    </div>

    <div class="right">
      <div class="card" style="text-align:center">
        <div class="small">Live Avatar — clothing auto-resizes to body width & height scales</div>
        <div id="avatarStage" class="avatar-stage" style="margin-top:8px">
          <div id="layerBody" class="avatar-layer"></div>
          <div id="layerArchetype" class="avatar-layer"></div>
          <div id="layerAttire" class="avatar-layer"></div>
          <div id="layerMask" class="avatar-layer"></div>
          <div id="layerAccessories" class="avatar-layer"></div>
        </div>

        <div class="controls">
          <button id="randomBtn" class="btn">Random</button>
          <button id="clearBtn" class="btn">Clear</button>
          <button id="toggleAnchorsBtn" class="btn">Toggle Anchors</button>
          <button id="exportBtn" class="btn" style="background:#10b981;color:#fff;border:none">Export PNG</button>
        </div>
      </div>

      <div class="card">
        <div class="small">Saved Wrestlers</div>
        <div id="charactersList" style="margin-top:8px"></div>
      </div>
    </div>
  </div>

  <!-- accessory configuration dialog -->
  <div id="overlay" class="overlay" style="display:none"></div>
  <div id="dialog" class="dialog" style="display:none">
    <div style="font-weight:600;margin-bottom:8px" id="dialogTitle">Configure Accessory</div>
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <img id="dialogImg" src="" alt="" style="width:64px;height:64px;object-fit:contain;border:1px solid #e6e7eb;padding:4px;background:#fff" />
      <div>
        <div id="dialogName" style="font-weight:600"></div>
        <div id="dialogDesc" class="small" style="max-width:360px"></div>
      </div>
    </div>

    <div style="margin-bottom:8px">
      <label class="small">Attach to</label>
      <select id="attachSelect" style="padding:6px;border:1px solid #d1d5db;border-radius:6px"></select>
    </div>

    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <label class="small">Mirror</label>
      <input id="mirrorCheckbox" type="checkbox" />
      <label class="small">Rotation</label>
      <input id="rotationRange" type="range" min="-180" max="180" value="0" />
      <div id="rotationValue" class="small">0°</div>
    </div>

    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="cancelDialog" class="btn">Cancel</button>
      <button id="addAccessoryBtn" class="btn primary">Add</button>
    </div>
  </div>

  <script>
    // API helpers
    const api = {
      getPresets: () => fetch('/api/presets').then(r => r.json()),
      listCharacters: () => fetch('/api/characters').then(r => r.json()),
      saveCharacter: (body) => fetch('/api/characters', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body)}).then(r => r.json())
    };

    let presets = null;

    // selection state:
    const sel = {
      archetypeId: null,
      attireId: null,
      maskId: null,
      accessories: [], // instances: { uid, id, attachTo, mirror, rotation, offset }
      heightPreset: 'average',
      heightScale: 1.0, // manual fine-tune: 0.8..1.2 mapped from range
      bodyTypeId: null
    };

    let anchorsVisible = false;

    function uid() { return 'u' + Math.random().toString(36).slice(2,9); }

    // --- Patched init: guarded fetch, logging, and defensive checks ---
    async function init() {
      try {
        presets = await api.getPresets();
      } catch (err) {
        console.error('Failed to fetch presets:', err);
        const bodyCont = document.getElementById('bodyTypes');
        bodyCont.innerHTML = '<div class="small">Failed to load presets from server. Check console/network.</div>';
        return;
      }

      console.log('presets loaded:', presets);

      // Validate shape
      if (!presets || !presets.bodyTypes) {
        console.error('Presets missing required key: bodyTypes', presets);
        const bodyCont = document.getElementById('bodyTypes');
        bodyCont.innerHTML = '<div class="small">Presets file is missing the "bodyTypes" section. Check /api/presets or presets.json.</div>';
        return;
      }

      // Render body types (many variants cover sizes + colors)
      const bodyCont = document.getElementById('bodyTypes');
      (presets.bodyTypes || []).forEach(bt => {
        const d = document.createElement('div');
        d.className = 'thumb';
        d.dataset.category = 'bodyTypes';
        d.dataset.id = bt.id;
        d.title = bt.name + (bt.description ? ' — ' + bt.description : '');
        const img = document.createElement('img');
        img.src = bt.image;
        img.alt = bt.name;
        const lbl = document.createElement('div');
        lbl.className = 'small';
        lbl.textContent = bt.name;
        d.appendChild(img); d.appendChild(lbl);

        d.addEventListener('click', () => {
          sel.bodyTypeId = bt.id;
          Array.from(bodyCont.children).forEach(c => c.style.outline = 'none');
          d.style.outline = '3px solid #2563eb';
          enableCustomizationIfReady();
          updateAvatar();
        });

        // support drag start
        d.draggable = true;
        d.addEventListener('dragstart', (ev) => {
          ev.dataTransfer.setData('application/json', JSON.stringify({ category: 'bodyTypes', id: bt.id }));
          ev.dataTransfer.effectAllowed = 'copy';
        });

        bodyCont.appendChild(d);
      });

      // heights controls
      const heightSelect = document.getElementById('heightSelect');
      heightSelect.addEventListener('change', () => {
        sel.heightPreset = heightSelect.value;
        const h = (presets.heights || []).find(h => h.id === sel.heightPreset);
        sel.heightScale = h?.offset?.scale ?? 1;
        document.getElementById('heightRange').value = Math.round(sel.heightScale * 100);
        document.getElementById('heightValue').textContent = 'Height scale: ' + Math.round(sel.heightScale * 100) + '%';
        updateAvatar();
      });

      document.getElementById('heightRange').addEventListener('input', (e) => {
        sel.heightScale = Number(e.target.value) / 100;
        document.getElementById('heightValue').textContent = 'Height scale: ' + Math.round(sel.heightScale * 100) + '%';
        updateAvatar();
      });

      // render customization lists (attire/masks/accessories)
      renderCustomizationLists();

      // control bindings
      document.getElementById('saveBtn').addEventListener('click', saveWrestler);
      document.getElementById('randomBtn').addEventListener('click', randomizeSelection);
      document.getElementById('clearBtn').addEventListener('click', clearSelection);
      document.getElementById('toggleAnchorsBtn').addEventListener('click', () => { anchorsVisible = !anchorsVisible; updateAvatar(); });
      document.getElementById('exportBtn').addEventListener('click', exportToPNG);

      // dialog handlers
      document.getElementById('cancelDialog').addEventListener('click', closeDialog);
      document.getElementById('overlay').addEventListener('click', closeDialog);

      // defaults
      const defaultH = (presets.heights || []).find(h => h.id === sel.heightPreset);
      sel.heightScale = defaultH?.offset?.scale ?? 1;
      document.getElementById('heightRange').value = Math.round(sel.heightScale * 100);
      document.getElementById('heightValue').textContent = 'Height scale: ' + Math.round(sel.heightScale * 100) + '%';

      initDrops();
      updateAvatar();
      loadCharacters();
    }

    // --- Patched renderCustomizationLists: defensive access to presets lists ---
    function renderCustomizationLists() {
      // attires
      const attCont = document.getElementById('attires');
      (presets.attire || []).forEach(a => {
        const d = document.createElement('div'); d.className = 'thumb';
        d.dataset.category = 'attire'; d.dataset.id = a.id;
        const img = document.createElement('img'); img.src = a.image; img.alt = a.name;
        const lbl = document.createElement('div'); lbl.className = 'small'; lbl.textContent = a.name;
        d.appendChild(img); d.appendChild(lbl);
        d.addEventListener('click', () => {
          if (!sel.bodyTypeId) { alert('Choose a body type first'); return; }
          sel.attireId = a.id;
          updateAvatar();
        });
        d.draggable = true;
        d.addEventListener('dragstart', ev => ev.dataTransfer.setData('application/json', JSON.stringify({ category: 'attire', id: a.id })));
        attCont.appendChild(d);
      });

      // masks
      const maskCont = document.getElementById('masks');
      (presets.masks || []).forEach(m => {
        const d = document.createElement('div'); d.className = 'thumb';
        d.dataset.category = 'masks'; d.dataset.id = m.id;
        const img = document.createElement('img'); img.src = m.image; img.alt = m.name;
        const lbl = document.createElement('div'); lbl.className = 'small'; lbl.textContent = m.name;
        d.appendChild(img); d.appendChild(lbl);
        d.addEventListener('click', () => {
          if (!sel.bodyTypeId) { alert('Choose a body type first'); return; }
          sel.maskId = m.id;
          updateAvatar();
        });
        d.draggable = true;
        d.addEventListener('dragstart', ev => ev.dataTransfer.setData('application/json', JSON.stringify({ category: 'masks', id: m.id })));
        maskCont.appendChild(d);
      });

      // accessories
      const accCont = document.getElementById('accessories');
      (presets.accessories || []).forEach(acc => {
        const d = document.createElement('div'); d.className = 'thumb';
        d.dataset.category = 'accessories'; d.dataset.id = acc.id;
        const img = document.createElement('img'); img.src = acc.image; img.alt = acc.name;
        const lbl = document.createElement('div'); lbl.className = 'small'; lbl.textContent = acc.name;
        d.appendChild(img); d.appendChild(lbl);
        d.addEventListener('click', () => {
          if (!sel.bodyTypeId) { alert('Choose a body type first'); return; }
          openAccessoryDialog(acc);
        });
        d.draggable = true;
        d.addEventListener('dragstart', ev => ev.dataTransfer.setData('application/json', JSON.stringify({ category: 'accessories', id: acc.id })));
        accCont.appendChild(d);
      });

      enableCustomizationIfReady();
    }

    // accessory dialog functions
    function openAccessoryDialog(item, category, prefill) {
      const overlay = document.getElementById('overlay'), dialog = document.getElementById('dialog');
      overlay.style.display = 'block'; dialog.style.display = 'block';
      document.getElementById('dialogTitle').textContent = 'Configure: ' + item.name;
      document.getElementById('dialogImg').src = item.image;
      document.getElementById('dialogName').textContent = item.name;
      document.getElementById('dialogDesc').textContent = item.description || '';

      const attachSelect = document.getElementById('attachSelect');
      attachSelect.innerHTML = '';

      // zones available (from archetypes + body anchorOffsets)
      const arch = presets.archetypes?.find(a => a.id === sel.archetypeId) || {};
      const body = presets.bodyTypes?.find(b => b.id === sel.bodyTypeId) || {};
      const zones = new Set(Object.keys((arch.anchors || {})).concat(Object.keys((body.anchorOffsets || {}))).concat(['head','torso','legs','left-leg','right-leg','left-shoulder','right-shoulder']));
      Array.from(zones).forEach(z => { const opt = document.createElement('option'); opt.value = z; opt.textContent = z; attachSelect.appendChild(opt); });

      document.getElementById('mirrorCheckbox').checked = prefill?.mirror || false;
      document.getElementById('rotationRange').value = prefill?.rotation ?? (item.offset?.rotation || 0);
      document.getElementById('rotationValue').textContent = document.getElementById('rotationRange').value + '°';
      if (prefill?.attachTo) attachSelect.value = prefill.attachTo;
      else attachSelect.value = item.defaultAttachTo || 'torso';

      document.getElementById('rotationRange').oninput = (e) => { document.getElementById('rotationValue').textContent = e.target.value + '°'; };

      document.getElementById('addAccessoryBtn').onclick = () => {
        const inst = {
          uid: uid(),
          id: item.id,
          attachTo: attachSelect.value,
          mirror: document.getElementById('mirrorCheckbox').checked,
          rotation: Number(document.getElementById('rotationRange').value),
          offset: { x: item.offset?.x || 0, y: item.offset?.y || 0, scale: item.offset?.scale || 1 }
        };
        if (prefill && prefill.uid) {
          const idx = sel.accessories.findIndex(a => a.uid === prefill.uid);
          if (idx !== -1) sel.accessories[idx] = Object.assign({}, sel.accessories[idx], inst);
        } else {
          sel.accessories.push(inst);
        }
        closeDialog(); renderAccessoryTray(); updateAvatar();
      };

      document.getElementById('cancelDialog').onclick = closeDialog;
      document.getElementById('overlay').onclick = closeDialog;
    }

    function closeDialog() { document.getElementById('overlay').style.display = 'none'; document.getElementById('dialog').style.display = 'none'; }

    function renderAccessoryTray() {
      const tray = document.getElementById('accessoryTray'); tray.innerHTML = '';
      if (!sel.accessories.length) { tray.innerHTML = '<div class="small">No accessories equipped</div>'; return; }
      const groups = {};
      sel.accessories.forEach(inst => { const zone = inst.attachTo || 'unassigned'; groups[zone] = groups[zone] || []; groups[zone].push(inst); });
      Object.keys(groups).forEach(zone => {
        const header = document.createElement('div'); header.className = 'small'; header.style.width='100%'; header.style.marginTop='6px'; header.textContent = zone; tray.appendChild(header);
        groups[zone].forEach(inst => {
          const it = presets.accessories.find(a => a.id === inst.id);
          const pill = document.createElement('div'); pill.className='accessory-pill';
          const img = document.createElement('img'); img.src = it.image; img.style.width='36px'; img.style.height='36px';
          const label = document.createElement('div'); label.className='small'; label.textContent = it.name + (inst.mirror ? ' ↔' : '') + ' ' + inst.rotation + '°';
          const edit = document.createElement('button'); edit.className='btn'; edit.textContent='Edit'; edit.onclick = () => openAccessoryDialog(it, 'accessories', inst);
          const rem = document.createElement('button'); rem.className='btn'; rem.textContent='Remove'; rem.onclick = () => { sel.accessories = sel.accessories.filter(a => a.uid !== inst.uid); renderAccessoryTray(); updateAvatar(); };
          pill.appendChild(img); pill.appendChild(label); pill.appendChild(edit); pill.appendChild(rem);
          tray.appendChild(pill);
        });
      });
    }

    // compute anchor with body type anchorOffsets
    function computeAnchorPosition(attachPoint) {
      const arche = presets.archetypes?.find(a => a.id === sel.archetypeId) || {};
      const body = presets.bodyTypes?.find(b => b.id === sel.bodyTypeId) || {};
      let base = null;
      if (arche.anchors && arche.anchors[attachPoint]) base = { x: arche.anchors[attachPoint].x, y: arche.anchors[attachPoint].y };
      if (!base && body.anchors && body.anchors[attachPoint]) base = { x: body.anchors[attachPoint].x, y: body.anchors[attachPoint].y };
      if (!base) base = { x: 50, y: 50 };
      if (body.anchorOffsets && body.anchorOffsets[attachPoint]) {
        base.x += body.anchorOffsets[attachPoint].x || 0;
        base.y += body.anchorOffsets[attachPoint].y || 0;
      }
      return base;
    }

    // apply proportional transform: width uses body.widthMultiplier, height uses sel.heightScale
    function applyProportionalTransform(el, leftPercent, topPercent, itemOffset, instance) {
      const body = presets.bodyTypes?.find(b => b.id === sel.bodyTypeId) || { widthMultiplier: 1 };
      const bodyWidth = body.widthMultiplier || 1.0;
      const hScale = sel.heightScale || 1.0;
      const scaleBase = itemOffset?.scale || 1;
      const scaleX = scaleBase * bodyWidth;
      const scaleY = scaleBase * hScale;
      const rotation = (instance?.rotation ?? itemOffset?.rotation) || 0;
      const mirror = instance?.mirror ? -1 : 1;
      const tx = (leftPercent + (itemOffset?.x || 0)) + '%';
      const ty = (topPercent + (itemOffset?.y || 0)) + '%';
      const sx = scaleX * (mirror === -1 ? -1 : 1);
      el.style.left = tx;
      el.style.top = ty;
      el.style.transform = `translate(-50%,-50%) scale(${sx},${scaleY}) rotate(${rotation}deg)`;
      el.style.zIndex = (itemOffset?.zIndex !== undefined) ? itemOffset.zIndex : 10;
    }

    function createLayeredElement(item, leftPercent, topPercent, instance) {
      const img = document.createElement('img');
      img.className = 'layered';
      img.src = item.image || '';
      img.alt = item.name || '';
      const itemOffset = instance?.offset || item.offset || { x:0, y:0, scale:1, rotation:0, zIndex:10 };
      applyProportionalTransform(img, leftPercent, topPercent, itemOffset, instance);
      img.style.cursor = 'pointer';
      return img;
    }

    function updateAvatar() {
      ['layerBody','layerArchetype','layerAttire','layerMask','layerAccessories'].forEach(id => document.getElementById(id).innerHTML = '');

      // body
      const body = presets.bodyTypes?.find(b => b.id === sel.bodyTypeId);
      if (body) {
        const layerBody = document.getElementById('layerBody');
        const left = body.offset?.x ?? 50; const top = body.offset?.y ?? 50;
        const el = createLayeredElement(body, left, top, null);
        layerBody.appendChild(el);
      }

      // archetype (optional)
      const arche = presets.archetypes?.find(a => a.id === sel.archetypeId);
      if (arche) {
        const layerArch = document.getElementById('layerArchetype');
        const left = arche.offset?.x ?? 50; const top = arche.offset?.y ?? 50;
        const el = createLayeredElement(arche, left, top, null);
        layerArch.appendChild(el);
      }

      // attire (position at torso anchor)
      const att = presets.attire?.find(a => a.id === sel.attireId);
      if (att) {
        const torso = computeAnchorPosition('torso');
        const layerAtt = document.getElementById('layerAttire');
        const el = createLayeredElement(att, torso.x, torso.y, null);
        layerAtt.appendChild(el);
      }

      // mask (position at head anchor)
      const mask = presets.masks?.find(m => m.id === sel.maskId);
      if (mask) {
        const head = computeAnchorPosition('head');
        const layerMask = document.getElementById('layerMask');
        const el = createLayeredElement(mask, head.x, head.y, null);
        layerMask.appendChild(el);
      }

      // accessories
      const accLayer = document.getElementById('layerAccessories');
      sel.accessories.forEach(inst => {
        const item = presets.accessories?.find(a => a.id === inst.id);
        if (!item) return;
        const attach = inst.attachTo || item.defaultAttachTo || 'torso';
        const anchor = computeAnchorPosition(attach);
        const finalX = anchor.x + (inst.offset?.x || item.offset?.x || 0);
        const finalY = anchor.y + (inst.offset?.y || item.offset?.y || 0);
        const el = createLayeredElement(item, finalX, finalY, inst);
        el.addEventListener('click', () => {
          sel.accessories = sel.accessories.filter(a => a.uid !== inst.uid);
          renderAccessoryTray(); updateAvatar();
        });
        accLayer.appendChild(el);
      });

      // anchor dots if debug on
      Array.from(document.querySelectorAll('.anchor-dot')).forEach(n => n.remove());
      if (anchorsVisible && sel.bodyTypeId) {
        const zones = ['head','torso','legs','left-leg','right-leg','left-shoulder','right-shoulder'];
        zones.forEach(z => {
          const a = computeAnchorPosition(z);
          const dot = document.createElement('div'); dot.className = 'anchor-dot';
          dot.style.left = a.x + '%'; dot.style.top = a.y + '%';
          document.getElementById('avatarStage').appendChild(dot);
        });
      }
    }

    function initDrops() {
      const stage = document.getElementById('avatarStage');
      stage.addEventListener('dragover', ev => { ev.preventDefault(); ev.dataTransfer.dropEffect = 'copy'; });
      stage.addEventListener('drop', ev => {
        ev.preventDefault();
        try {
          const data = JSON.parse(ev.dataTransfer.getData('application/json'));
          if (!data) return;
          if (data.category === 'accessories') {
            if (!sel.bodyTypeId) { alert('Pick a body type first'); return; }
            const rect = stage.getBoundingClientRect();
            const x = ((ev.clientX - rect.left) / rect.width) * 100;
            const y = ((ev.clientY - rect.top) / rect.height) * 100;
            const nearest = findNearestAnchor(x, y);
            const item = presets.accessories?.find(a => a.id === data.id);
            if (!item) return;
            const instance = {
              uid: uid(),
              id: item.id,
              attachTo: nearest || item.defaultAttachTo || 'torso',
              mirror: false,
              rotation: item.offset?.rotation || 0,
              offset: { x: (item.offset?.x || 0) + (x - (computeAnchorPosition(nearest)?.x || x)), y: (item.offset?.y || 0) + (y - (computeAnchorPosition(nearest)?.y || y)), scale: item.offset?.scale || 1 }
            };
            sel.accessories.push(instance);
            renderAccessoryTray(); updateAvatar();
          } else {
            // equip other categories
            if (data.category === 'attire') sel.attireId = data.id;
            if (data.category === 'masks') sel.maskId = data.id;
            if (data.category === 'bodyTypes') { sel.bodyTypeId = data.id; enableCustomizationIfReady(); }
            updateAvatar();
          }
        } catch (e) {
          console.warn('drop parse fail', e);
        }
      });
    }

    function findNearestAnchor(x, y) {
      const arch = presets.archetypes?.find(a => a.id === sel.archetypeId) || {};
      const body = presets.bodyTypes?.find(b => b.id === sel.bodyTypeId) || {};
      const candidates = new Set(Object.keys(arch.anchors || {}).concat(Object.keys(body.anchorOffsets || {})).concat(['head','torso','legs','left-leg','right-leg','left-shoulder','right-shoulder']));
      let best = null; let bestD = Infinity;
      Array.from(candidates).forEach(z => { const a = computeAnchorPosition(z); const dx = a.x - x; const dy = a.y - y; const d = Math.hypot(dx,dy); if (d < bestD) { best = z; bestD = d; } });
      return best;
    }

    // Export to PNG similar to previous implementation — respects widthMultiplier and heightScale
    async function exportToPNG() {
      const stage = document.getElementById('avatarStage');
      const targetW = 1200;
      const targetH = Math.round(targetW * (stage.clientHeight / stage.clientWidth));
      const canvas = document.createElement('canvas'); canvas.width = targetW; canvas.height = targetH;
      const ctx = canvas.getContext('2d');
      const loadImage = src => new Promise((res,rej)=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=rej; i.src=src; });

      const drawList = [];
      const stageW = stage.clientWidth, stageH = stage.clientHeight;

      function enqueue(item, leftPercent, topPercent, instance) {
        if (!item || !item.image) return;
        const off = instance?.offset || item.offset || { x:0, y:0, scale:1, rotation:0, zIndex:10 };
        const body = presets.bodyTypes?.find(b => b.id === sel.bodyTypeId) || { widthMultiplier: 1 };
        const sx = (off.scale || 1) * (body.widthMultiplier || 1);
        const sy = (off.scale || 1) * sel.heightScale;
        const px = { x: leftPercent / 100 * stageW, y: topPercent / 100 * stageH };
        drawList.push({ item, px, sx, sy, rotation: (instance?.rotation ?? off.rotation) || 0, mirror: instance?.mirror || false, z: off.zIndex || 10 });
      }

      const body = presets.bodyTypes?.find(b => b.id === sel.bodyTypeId);
      if (body) enqueue(body, body.offset?.x ?? 50, body.offset?.y ?? 50, null);
      const arche = presets.archetypes?.find(a => a.id === sel.archetypeId);
      if (arche) enqueue(arche, arche.offset?.x ?? 50, arche.offset?.y ?? 50, null);
      const att = presets.attire?.find(a => a.id === sel.attireId);
      if (att) { const torso = computeAnchorPosition('torso'); enqueue(att, torso.x, torso.y, null); }
      const mask = presets.masks?.find(m => m.id === sel.maskId);
      if (mask) { const head = computeAnchorPosition('head'); enqueue(mask, head.x, head.y, null); }
      for (const inst of sel.accessories) {
        const it = presets.accessories?.find(a => a.id === inst.id);
        if (!it) continue;
        const attach = inst.attachTo || it.defaultAttachTo || 'torso';
        const anchor = computeAnchorPosition(attach);
        const finalX = anchor.x + (inst.offset?.x || it.offset?.x || 0);
        const finalY = anchor.y + (inst.offset?.y || it.offset?.y || 0);
        enqueue(it, finalX, finalY, inst);
      }

      drawList.sort((a,b) => (a.z||10)-(b.z||10));

      try {
        const loaded = await Promise.all(drawList.map(d => loadImage(d.item.image)));
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
        for (let i=0;i<drawList.length;i++) {
          const d = drawList[i]; const img = loaded[i];
          const left = d.px.x * (canvas.width / stageW);
          const top = d.px.y * (canvas.height / stageH);
          const drawW = img.naturalWidth * d.sx * (canvas.width / stageW);
          const drawH = img.naturalHeight * d.sy * (canvas.height / stageH);
          ctx.save();
          ctx.translate(left, top);
          if (d.mirror) ctx.scale(-1,1);
          const rad = d.rotation * Math.PI / 180;
          if (rad) ctx.rotate(rad);
          ctx.drawImage(img, -drawW/2 * (d.mirror ? -1 : 1), -drawH/2, drawW * (d.mirror ? -1 : 1), drawH);
          ctx.restore();
        }
        const url = canvas.toDataURL('image/png');
        const a = document.createElement('a'); a.href = url; a.download = (document.getElementById('name').value || 'wrestler') + '.png'; document.body.appendChild(a); a.click(); a.remove();
      } catch (e) {
        alert('Export failed: ' + e.message);
      }
    }

    // Save (server expects accessoryIds array) — we keep compatibility
    async function saveWrestler() {
      const name = document.getElementById('name').value.trim();
      if (!name) { alert('Enter a name'); return; }
      const accessoryIds = sel.accessories.map(a => a.id);
      const payload = {
        name,
        notes: '',
        selection: {
          archetypeId: sel.archetypeId,
          attireId: sel.attireId,
          maskId: sel.maskId,
          accessoryIds,
          heightId: sel.heightPreset,
          bodyTypeId: sel.bodyTypeId
        }
      };
      try {
        await api.saveCharacter(payload);
        alert('Saved ' + name);
        loadCharacters();
      } catch (e) {
        alert('Save failed: ' + e.message);
      }
    }

    // utility functions: accessory tray, randomize, clear, load characters
    function renderAccessoryTray() {
      const tray = document.getElementById('accessoryTray'); tray.innerHTML = '';
      if (!sel.accessories.length) { tray.innerHTML = '<div class="small">No accessories equipped</div>'; return; }
      const groups = {};
      sel.accessories.forEach(inst => { const zone = inst.attachTo || 'unassigned'; groups[zone] = groups[zone] || []; groups[zone].push(inst); });
      Object.keys(groups).forEach(zone => {
        const header = document.createElement('div'); header.className='small'; header.style.width='100%'; header.style.marginTop='6px'; header.textContent = zone; tray.appendChild(header);
        groups[zone].forEach(inst => {
          const it = presets.accessories.find(a => a.id === inst.id);
          const pill = document.createElement('div'); pill.className='accessory-pill';
          const img = document.createElement('img'); img.src = it.image; img.style.width='36px'; img.style.height='36px';
          const label = document.createElement('div'); label.className='small'; label.textContent = it.name + (inst.mirror ? ' ↔' : '') + ' ' + inst.rotation + '°';
          const edit = document.createElement('button'); edit.className='btn'; edit.textContent='Edit'; edit.onclick = () => openAccessoryDialog(it,'accessories',inst);
          const rem = document.createElement('button'); rem.className='btn'; rem.textContent='Remove'; rem.onclick = () => { sel.accessories = sel.accessories.filter(a => a.uid !== inst.uid); renderAccessoryTray(); updateAvatar(); };
          pill.appendChild(img); pill.appendChild(label); pill.appendChild(edit); pill.appendChild(rem);
          tray.appendChild(pill);
        });
      });
    }

    function randomizeSelection() {
      const rand = arr => arr[Math.floor(Math.random() * arr.length)].id;
      sel.bodyTypeId = rand(presets.bodyTypes || []);
      sel.heightPreset = rand(presets.heights || []);
      const h = (presets.heights || []).find(h => h.id === sel.heightPreset);
      sel.heightScale = h?.offset?.scale ?? 1;
      sel.archetypeId = rand(presets.archetypes || []);
      sel.attireId = rand(presets.attire || []);
      sel.maskId = rand(presets.masks || []);
      sel.accessories = [];
      renderAccessoryTray(); updateAvatar(); enableCustomizationIfReady();
      document.getElementById('heightRange').value = Math.round(sel.heightScale * 100);
      document.getElementById('heightValue').textContent = 'Height scale: ' + Math.round(sel.heightScale * 100) + '%';
    }

    function clearSelection() {
      sel.archetypeId = null; sel.attireId = null; sel.maskId = null; sel.accessories = [];
      sel.heightPreset = 'average'; sel.heightScale = 1; sel.bodyTypeId = null;
      document.getElementById('heightRange').value = 100; document.getElementById('heightValue').textContent = 'Height scale: 100%';
      Array.from(document.querySelectorAll('#bodyTypes .thumb')).forEach(el => el.style.outline = 'none');
      renderAccessoryTray(); updateAvatar(); enableCustomizationIfReady();
    }

    // --- Patched loadCharacters: defensive early return if API missing ---
    async function loadCharacters() {
      const out = document.getElementById('charactersList'); out.innerHTML = '';
      if (!api || !api.listCharacters) { out.innerHTML = '<div class="small">Character API not available</div>'; return; }
      try {
        const chars = await api.listCharacters();
        if (!chars.length) { out.innerHTML = '<div class="small">No saved wrestlers</div>'; return; }
        chars.forEach(c => {
          const row = document.createElement('div'); row.style.padding='8px 0'; row.style.borderBottom='1px solid #f3f4f6';
          row.innerHTML = '<strong>' + c.name + '</strong><div class="small">Archetype: ' + (c.selection?.archetypeId || '-') + '</div>';
          const loadBtn = document.createElement('button'); loadBtn.textContent='Load'; loadBtn.className='btn'; loadBtn.style.marginLeft='8px';
          loadBtn.addEventListener('click', () => {
            sel.archetypeId = c.selection?.archetypeId || sel.archetypeId;
            sel.attireId = c.selection?.attireId || sel.attireId;
            sel.maskId = c.selection?.maskId || sel.maskId;
            sel.heightPreset = c.selection?.heightId || sel.heightPreset;
            const h = (presets.heights || []).find(h => h.id === sel.heightPreset);
            sel.heightScale = h?.offset?.scale ?? 1;
            sel.bodyTypeId = c.selection?.bodyTypeId || sel.bodyTypeId;
            // load accessories as bare instances (user may edit)
            sel.accessories = (c.selection?.accessoryIds || []).map(id => {
              const item = presets.accessories?.find(a => a.id === id);
              return { uid: uid(), id, attachTo: item?.defaultAttachTo || 'torso', mirror: false, rotation: 0, offset: { x: item?.offset?.x || 0, y: item?.offset?.y || 0, scale: item?.offset?.scale || 1 } };
            });
            renderAccessoryTray(); updateAvatar(); enableCustomizationIfReady();
            document.getElementById('heightRange').value = Math.round(sel.heightScale * 100); document.getElementById('heightValue').textContent = 'Height scale: ' + Math.round(sel.heightScale * 100) + '%';
            // mark chosen body
            Array.from(document.querySelectorAll('#bodyTypes .thumb')).forEach(el => el.style.outline = el.dataset.id === sel.bodyTypeId ? '3px solid #2563eb' : 'none');
          });
          row.appendChild(loadBtn);
          out.appendChild(row);
        });
      } catch (e) {
        out.textContent = 'Failed to load saved wrestlers';
      }
    }

    // initialize drag handlers for thumbnails (some created dynamically)
    function initThumbnailDrags() {
      document.querySelectorAll('.thumb').forEach(t => {
        t.addEventListener('dragstart', (ev) => {
          const category = t.dataset.category;
          const id = t.dataset.id;
          if (category && id) ev.dataTransfer.setData('application/json', JSON.stringify({ category, id }));
        });
      });
    }

    // initial boot
    init().then(() => {
      // small delay to ensure thumbs exist, then wire dragstart for dynamically-created thumbs
      setTimeout(initThumbnailDrags, 200);
    }).catch(e => { console.error(e); alert('Init failed: ' + e.message); });
  </script>
</body>
</html>
