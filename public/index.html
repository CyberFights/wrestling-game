<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Wrestling Creator — Zones, Mirror & Export</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial; margin:16px; max-width:1300px; }
    .layout { display:flex; gap:16px; align-items:flex-start; }
    .left { flex:1; }
    .right { width:520px; }
    .card { border:1px solid #e6e7eb; border-radius:8px; padding:12px; margin-bottom:12px; background:#fff; }
    .thumb-grid { display:flex; gap:8px; flex-wrap:wrap; }
    .thumb { width:84px; height:84px; border:1px solid #e6e7eb; border-radius:6px; padding:6px; display:flex; flex-direction:column; align-items:center; justify-content:center; background:white; cursor:pointer; }
    .thumb img { max-width:64px; max-height:48px; object-fit:contain; }
    .small { font-size:12px; color:#6b7280; }
    .avatar-stage { position:relative; width:420px; height:630px; background:#fff; border:1px solid #ddd; border-radius:6px; overflow:hidden; margin:8px auto; }
    .avatar-layer { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }
    .layered { position:absolute; transform-origin:center center; pointer-events:auto; will-change:transform,left,top; }
    .accessory-pill { display:flex; align-items:center; gap:6px; padding:4px 6px; border-radius:6px; border:1px solid #e6e7eb; background:#fff; }
    .controls { display:flex; gap:8px; justify-content:center; margin-top:8px; }
    .dialog { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); background:#fff; border:1px solid #d1d5db; padding:12px; border-radius:8px; z-index:9999; box-shadow:0 6px 24px rgba(15,23,42,0.15); }
    .overlay { position:fixed; inset:0; background:rgba(0,0,0,0.35); z-index:9998; }
    input[type="range"] { width:160px; }
    .anchor-dot { position:absolute; width:10px; height:10px; border-radius:50%; background:rgba(37,99,235,0.9); transform:translate(-50%,-50%); pointer-events:none; }
  </style>
</head>
<body>
  <h1>Wrestling Creator — Zones, Mirror & Export</h1>

  <div class="layout">
    <div class="left">
      <div class="card">
        <div style="display:flex; gap:8px;">
          <input id="name" placeholder="Wrestler name" style="flex:1;padding:8px;border:1px solid #e6e7eb;border-radius:6px" />
          <button id="saveBtn" style="background:#2563eb;color:#fff;border:none;padding:8px 12px;border-radius:6px;cursor:pointer">Save</button>
        </div>
        <div class="small" style="margin-top:6px">Drag thumbnails onto the avatar. Dropped accessories snap to nearest anchor; you can edit mirror/rotation before or after equipping.</div>
      </div>

      <div class="card">
        <div class="small">Archetypes</div>
        <div id="archetypes" class="thumb-grid"></div>
      </div>

      <div class="card">
        <div class="small">Attire</div>
        <div id="attires" class="thumb-grid"></div>
      </div>

      <div class="card">
        <div class="small">Masks</div>
        <div id="masks" class="thumb-grid"></div>
      </div>

      <div class="card">
        <div class="small">Accessories</div>
        <div id="accessories" class="thumb-grid"></div>
        <div class="small" style="margin-top:6px">Click an accessory to open configuration dialog (choose attach zone, mirror, rotation) and add multiple instances.</div>
      </div>

      <div class="card">
        <div class="small">Heights / Body / Skin</div>
        <div id="heights" class="thumb-grid" style="margin-top:8px"></div>
        <div id="bodyTypes" class="thumb-grid" style="margin-top:8px"></div>
        <div id="skinColors" class="thumb-grid" style="margin-top:8px"></div>
      </div>

      <div class="card">
        <div class="small">Accessory Tray (equipped)</div>
        <div id="accessoryTray" style="display:flex;gap:6px;flex-wrap:wrap;padding:8px;border:1px dashed #e6e7eb;border-radius:8px;min-height:48px;margin-top:8px"></div>
        <div class="small" style="margin-top:8px">Grouped by attach zones; click an item in the tray to edit or remove.</div>
      </div>
    </div>

    <div class="right">
      <div class="card" style="text-align:center">
        <div class="small">Live Avatar — click accessory on avatar to remove (or edit via tray)</div>
        <div id="avatarStage" class="avatar-stage" style="margin-top:8px">
          <div id="layerSkin" class="avatar-layer"></div>
          <div id="layerBody" class="avatar-layer"></div>
          <div id="layerArchetype" class="avatar-layer"></div>
          <div id="layerAttire" class="avatar-layer"></div>
          <div id="layerMask" class="avatar-layer"></div>
          <div id="layerAccessories" class="avatar-layer"></div>
        </div>

        <div class="controls">
          <button id="randomBtn">Random</button>
          <button id="clearBtn">Clear</button>
          <button id="toggleAnchorsBtn">Toggle Anchors</button>
          <button id="exportBtn" style="background:#10b981;color:#fff;border:none;padding:8px 12px;border-radius:6px;cursor:pointer">Export PNG</button>
        </div>
      </div>

      <div class="card">
        <div class="small">Saved Wrestlers</div>
        <div id="charactersList" style="margin-top:8px"></div>
      </div>
    </div>
  </div>

  <!-- accessory configure dialog -->
  <div id="overlay" style="display:none" class="overlay"></div>
  <div id="dialog" style="display:none" class="dialog" role="dialog" aria-modal="true">
    <div style="font-weight:600;margin-bottom:8px" id="dialogTitle">Configure Accessory</div>
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <img id="dialogImg" src="" alt="" style="width:64px;height:64px;object-fit:contain;border:1px solid #e6e7eb;padding:4px;background:#fff" />
      <div>
        <div id="dialogName" style="font-weight:600"></div>
        <div id="dialogDesc" class="small" style="max-width:360px"></div>
      </div>
    </div>

    <div style="margin-bottom:8px">
      <label class="small">Attach to</label>
      <select id="attachSelect" style="padding:6px;border:1px solid #d1d5db;border-radius:6px"></select>
    </div>

    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <label class="small">Mirror</label>
      <input id="mirrorCheckbox" type="checkbox" />
      <label class="small">Rotation</label>
      <input id="rotationRange" type="range" min="-180" max="180" value="0" />
      <div id="rotationValue" class="small">0°</div>
    </div>

    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="cancelDialog">Cancel</button>
      <button id="addAccessoryBtn" style="background:#2563eb;color:#fff;border:none;padding:8px 12px;border-radius:6px;cursor:pointer">Add Accessory</button>
    </div>
  </div>

  <script>
    // API helpers
    const api = {
      getPresets: () => fetch('/api/presets').then(r => r.json()),
      listCharacters: () => fetch('/api/characters').then(r => r.json()),
      saveCharacter: (body) => fetch('/api/characters', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body)}).then(r => r.json())
    };

    let presets = null;
    // current selection and equipped accessories
    const sel = {
      archetypeId: null,
      attireId: null,
      maskId: null,
      // accessories: array of instances { uid, id, attachTo, mirror, rotation, offset: {x,y,scale} }
      accessories: [],
      heightId: null,
      bodyTypeId: null,
      skinColorId: null
    };

    let anchorsVisible = false;

    // Utilities
    function uid() { return 'u' + Math.random().toString(36).slice(2,9); }

    function createThumb(item, category) {
      const d = document.createElement('div');
      d.className = 'thumb';
      d.draggable = true;
      d.dataset.id = item.id;
      d.dataset.category = category;
      const img = document.createElement('img');
      img.src = item.image || '';
      img.alt = item.name;
      const lbl = document.createElement('div');
      lbl.className = 'small';
      lbl.textContent = item.name;
      d.appendChild(img);
      d.appendChild(lbl);

      d.addEventListener('click', () => openAccessoryDialog(item, category));
      d.addEventListener('dragstart', ev => {
        ev.dataTransfer.setData('application/json', JSON.stringify({ category, id: item.id }));
        ev.dataTransfer.effectAllowed = 'copy';
      });
      return d;
    }

    function openAccessoryDialog(item, category, prefill) {
      // category param used to restrict attach options list; but most accessories allow all zones
      const overlay = document.getElementById('overlay');
      const dialog = document.getElementById('dialog');
      overlay.style.display = 'block';
      dialog.style.display = 'block';
      document.getElementById('dialogTitle').textContent = 'Configure: ' + item.name;
      document.getElementById('dialogImg').src = item.image || '';
      document.getElementById('dialogName').textContent = item.name;
      document.getElementById('dialogDesc').textContent = item.description || '';

      const attachSelect = document.getElementById('attachSelect');
      attachSelect.innerHTML = '';
      // gather available zones from current archetype anchors
      const arch = presets.archetypes.find(a => a.id === sel.archetypeId) || {};
      const body = presets.bodyTypes.find(b => b.id === sel.bodyTypeId) || {};
      // union of arch.anchors keys + default zones
      const zones = new Set(Object.keys((arch.anchors || {})).concat(Object.keys((body.anchorOffsets || {}))).concat(['head','torso','legs','left-leg','right-leg','left-shoulder','right-shoulder']));
      Array.from(zones).forEach(z => {
        const opt = document.createElement('option');
        opt.value = z;
        opt.textContent = z;
        attachSelect.appendChild(opt);
      });

      // prefill options if provided
      document.getElementById('mirrorCheckbox').checked = prefill?.mirror || false;
      document.getElementById('rotationRange').value = prefill?.rotation ?? (item.offset?.rotation || 0);
      document.getElementById('rotationValue').textContent = document.getElementById('rotationRange').value + '°';
      if (prefill?.attachTo) attachSelect.value = prefill.attachTo;
      else attachSelect.value = item.defaultAttachTo || 'torso';

      // handlers
      document.getElementById('cancelDialog').onclick = closeDialog;
      document.getElementById('overlay').onclick = closeDialog;
      document.getElementById('rotationRange').oninput = (e) => {
        document.getElementById('rotationValue').textContent = e.target.value + '°';
      };

      // add button
      document.getElementById('addAccessoryBtn').onclick = () => {
        const instance = {
          uid: uid(),
          id: item.id,
          attachTo: attachSelect.value,
          mirror: document.getElementById('mirrorCheckbox').checked,
          rotation: Number(document.getElementById('rotationRange').value),
          offset: { x: item.offset?.x || 0, y: item.offset?.y || 0, scale: item.offset?.scale || 1 }
        };
        // If prefill has uid => editing an existing instance: replace
        if (prefill && prefill.uid) {
          const idx = sel.accessories.findIndex(a => a.uid === prefill.uid);
          if (idx !== -1) sel.accessories[idx] = Object.assign({}, sel.accessories[idx], instance);
        } else {
          sel.accessories.push(instance);
        }
        closeDialog();
        renderAccessoryTray();
        updateAvatar();
      };
    }

    function closeDialog() {
      document.getElementById('overlay').style.display = 'none';
      document.getElementById('dialog').style.display = 'none';
    }

    function equipFromThumb(category, id) {
      switch(category) {
        case 'archetypes': sel.archetypeId = id; break;
        case 'attire': sel.attireId = id; break;
        case 'masks': sel.maskId = id; break;
        case 'heights': sel.heightId = id; break;
        case 'bodyTypes': sel.bodyTypeId = id; break;
        case 'skinColors': sel.skinColorId = id; break;
        case 'accessories':
          // open dialog for accessory configuration
          const item = presets.accessories.find(x => x.id === id);
          if (item) openAccessoryDialog(item, category);
          break;
      }
      renderAccessoryTray();
      updateAvatar();
    }

    // compute anchor position from archetype anchors + bodyType anchorOffsets
    function computeAnchorPosition(attachPoint) {
      const arche = presets.archetypes.find(a => a.id === sel.archetypeId) || {};
      const body = presets.bodyTypes.find(b => b.id === sel.bodyTypeId) || {};
      let base = null;
      if (arche.anchors && arche.anchors[attachPoint]) base = { x: arche.anchors[attachPoint].x, y: arche.anchors[attachPoint].y };
      if (!base && body.anchors && body.anchors[attachPoint]) base = { x: body.anchors[attachPoint].x, y: body.anchors[attachPoint].y };
      if (!base) base = { x: 50, y: 50 };
      if (body.anchorOffsets && body.anchorOffsets[attachPoint]) {
        base.x += body.anchorOffsets[attachPoint].x || 0;
        base.y += body.anchorOffsets[attachPoint].y || 0;
      }
      return base;
    }

    // compute nearest anchor zone to a drop point (dropX, dropY in percent)
    function findNearestAnchor(dropX, dropY) {
      const arch = presets.archetypes.find(a => a.id === sel.archetypeId) || {};
      const body = presets.bodyTypes.find(b => b.id === sel.bodyTypeId) || {};
      const candidateZones = new Set(Object.keys(arch.anchors || {}).concat(Object.keys(body.anchorOffsets || {})).concat(['head','torso','legs','left-leg','right-leg','left-shoulder','right-shoulder']));
      let best = null;
      let bestDist = Infinity;
      Array.from(candidateZones).forEach(z => {
        const anchor = computeAnchorPosition(z);
        const dx = anchor.x - dropX;
        const dy = anchor.y - dropY;
        const d = Math.sqrt(dx*dx + dy*dy);
        if (d < bestDist) { bestDist = d; best = z; }
      });
      return best;
    }

    // render accessory tray grouped by attachTo
    function renderAccessoryTray() {
      const tray = document.getElementById('accessoryTray');
      tray.innerHTML = '';
      // group by attachTo
      const groups = {};
      sel.accessories.forEach(inst => {
        const zone = inst.attachTo || 'unassigned';
        groups[zone] = groups[zone] || [];
        groups[zone].push(inst);
      });
      Object.keys(groups).forEach(zone => {
        const header = document.createElement('div');
        header.className = 'small';
        header.style.width = '100%';
        header.style.marginTop = '6px';
        header.textContent = zone;
        tray.appendChild(header);
        groups[zone].forEach(inst => {
          const it = presets.accessories.find(a => a.id === inst.id);
          const pill = document.createElement('div'); pill.className = 'accessory-pill';
          const img = document.createElement('img'); img.src = it.image; img.style.width='36px'; img.style.height='36px';
          const label = document.createElement('div'); label.className='small'; label.textContent = it.name + (inst.mirror ? ' ↔' : '') + ' ' + inst.rotation + '°';
          const edit = document.createElement('button'); edit.textContent='Edit'; edit.style.marginLeft='8px';
          edit.onclick = () => openAccessoryDialog(it, 'accessories', inst);
          const rem = document.createElement('button'); rem.textContent='Remove'; rem.style.marginLeft='4px';
          rem.onclick = () => { sel.accessories = sel.accessories.filter(a => a.uid !== inst.uid); renderAccessoryTray(); updateAvatar(); };
          pill.appendChild(img); pill.appendChild(label); pill.appendChild(edit); pill.appendChild(rem);
          tray.appendChild(pill);
        });
      });
      if (sel.accessories.length === 0) tray.innerHTML = '<div class="small">No accessories equipped</div>';
    }

    // create layered image element (for DOM avatar) with transforms applied
    function createLayeredImageElement(item, leftPercent, topPercent, instance) {
      const img = document.createElement('img');
      img.className = 'layered';
      img.src = item.image || '';
      img.alt = item.name || '';
      const off = instance?.offset || item.offset || { x:0, y:0, scale:1, rotation:0, zIndex:10 };
      const x = (leftPercent !== undefined) ? (leftPercent + (off.x || 0)) : (item.offset?.x || 50);
      const y = (topPercent !== undefined) ? (topPercent + (off.y || 0)) : (item.offset?.y || 50);
      const scale = off.scale || 1;
      const rot = (instance?.rotation ?? off.rotation) || 0;
      let transform = `translate(-50%,-50%) scale(${scale}) rotate(${rot}deg)`;
      img.style.left = x + '%';
      img.style.top = y + '%';
      img.style.zIndex = (off.zIndex !== undefined) ? off.zIndex : 10;
      if (instance?.mirror) {
        // apply mirror by adding an additional scaleX(-1)
        transform = `translate(-50%,-50%) scale(${-scale},${scale}) rotate(${rot}deg)`;
      }
      img.style.transform = transform;
      img.style.cursor = 'pointer';
      return img;
    }

    // Update the DOM avatar render and anchor dots (for debugging)
    function updateAvatar() {
      const layerIds = ['layerSkin','layerBody','layerArchetype','layerAttire','layerMask','layerAccessories'];
      layerIds.forEach(id => document.getElementById(id).innerHTML = '');

      function placeLayer(layerId, item) {
        if (!item) return;
        const left = item.offset?.x ?? 50;
        const top = item.offset?.y ?? 50;
        const el = createLayeredImageElement(item, left, top, null);
        document.getElementById(layerId).appendChild(el);
      }

      placeLayer('layerSkin', presets.skinColors.find(s => s.id === sel.skinColorId));
      placeLayer('layerBody', presets.bodyTypes.find(b => b.id === sel.bodyTypeId));
      placeLayer('layerArchetype', presets.archetypes.find(a => a.id === sel.archetypeId));
      placeLayer('layerAttire', presets.attire.find(a => a.id === sel.attireId));
      placeLayer('layerMask', presets.masks.find(m => m.id === sel.maskId));

      // accessories: place each accessory at anchor+instance.offset (instance.offset x/y are additive in percent)
      const accLayer = document.getElementById('layerAccessories');
      sel.accessories.forEach(inst => {
        const item = presets.accessories.find(a => a.id === inst.id);
        if (!item) return;
        const attachTo = inst.attachTo || item.defaultAttachTo || 'torso';
        const anchor = computeAnchorPosition(attachTo);
        // final pos = anchor + instance.offset (percent)
        const finalX = anchor.x + (inst.offset?.x || item.offset?.x || 0);
        const finalY = anchor.y + (inst.offset?.y || item.offset?.y || 0);
        const el = createLayeredImageElement(item, finalX, finalY, inst);
        // clicking accessory on avatar removes it (quick)
        el.addEventListener('click', () => {
          sel.accessories = sel.accessories.filter(a => a.uid !== inst.uid);
          renderAccessoryTray(); updateAvatar();
        });
        accLayer.appendChild(el);
      });

      // draw anchor dots if visible
      Array.from(document.querySelectorAll('.anchor-dot')).forEach(n => n.remove());
      if (anchorsVisible) {
        const arch = presets.archetypes.find(a => a.id === sel.archetypeId) || {};
        ['head','torso','legs','left-leg','right-leg','left-shoulder','right-shoulder'].forEach(zone => {
          const anchor = computeAnchorPosition(zone);
          const dot = document.createElement('div'); dot.className = 'anchor-dot';
          dot.style.left = anchor.x + '%'; dot.style.top = anchor.y + '%';
          document.getElementById('avatarStage').appendChild(dot);
        });
      }
    }

    // handle drag-drop on avatar: snap to nearest anchor
    function initDropHandlers() {
      const stage = document.getElementById('avatarStage');
      stage.addEventListener('dragover', ev => { ev.preventDefault(); ev.dataTransfer.dropEffect = 'copy'; });
      stage.addEventListener('drop', ev => {
        ev.preventDefault();
        try {
          const data = JSON.parse(ev.dataTransfer.getData('application/json'));
          if (!data) return;
          if (data.category === 'accessories') {
            // compute drop point in percent
            const rect = stage.getBoundingClientRect();
            const x = ((ev.clientX - rect.left) / rect.width) * 100;
            const y = ((ev.clientY - rect.top) / rect.height) * 100;
            const nearest = findNearestAnchor(x, y);
            const item = presets.accessories.find(a => a.id === data.id);
            if (!item) return;
            // create instance using item's default offset/rotation
            const instance = {
              uid: uid(),
              id: item.id,
              attachTo: nearest || item.defaultAttachTo || 'torso',
              mirror: false,
              rotation: item.offset?.rotation || 0,
              offset: { x: (item.offset?.x || 0) + (x - (computeAnchorPosition(nearest)?.x || x)), y: (item.offset?.y || 0) + (y - (computeAnchorPosition(nearest)?.y || y)), scale: item.offset?.scale || 1 }
            };
            sel.accessories.push(instance);
            renderAccessoryTray(); updateAvatar();
          } else {
            equipFromThumb(data.category, data.id);
          }
        } catch (e) {
          console.warn('drop data parse failed', e);
        }
      });
    }

    // Export to PNG: resolve and draw all images to a canvas in correct z-order and transforms
    async function exportToPNG() {
      const stage = document.getElementById('avatarStage');
      // set a higher resolution canvas for export
      const targetW = 1200;
      const targetH = Math.round(targetW * (stage.clientHeight / stage.clientWidth));
      const canvas = document.createElement('canvas');
      canvas.width = targetW;
      canvas.height = targetH;
      const ctx = canvas.getContext('2d');

      // helper to load image
      const loadImage = (src) => new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });

      // determine draw scale from DOM stage to canvas
      const scaleX = canvas.width / stage.clientWidth;
      const scaleY = canvas.height / stage.clientHeight;

      // draw order: skin, body, archetype, attire, mask, accessories (sorted by zIndex)
      const drawItems = [];

      function enqueue(item, leftPercent, topPercent, instance) {
        if (!item || !item.image) return;
        const off = instance?.offset || item.offset || { x:0, y:0, scale:1, rotation:0, zIndex:10 };
        const left = (leftPercent / 100) * canvas.width;
        const top = (topPercent / 100) * canvas.height;
        drawItems.push({ item, left, top, instance, off });
      }

      enqueue(presets.skinColors.find(s => s.id === sel.skinColorId), presets.skinColors.find(s => s.id === sel.skinColorId)?.offset?.x ?? 50, presets.skinColors.find(s => s.id === sel.skinColorId)?.offset?.y ?? 50, null);
      enqueue(presets.bodyTypes.find(b => b.id === sel.bodyTypeId), presets.bodyTypes.find(b => b.id === sel.bodyTypeId)?.offset?.x ?? 50, presets.bodyTypes.find(b => b.id === sel.bodyTypeId)?.offset?.y ?? 50, null);
      enqueue(presets.archetypes.find(a => a.id === sel.archetypeId), presets.archetypes.find(a => a.id === sel.archetypeId)?.offset?.x ?? 50, presets.archetypes.find(a => a.id === sel.archetypeId)?.offset?.y ?? 50, null);
      enqueue(presets.attire.find(a => a.id === sel.attireId), presets.attire.find(a => a.id === sel.attireId)?.offset?.x ?? 50, presets.attire.find(a => a.id === sel.attireId)?.offset?.y ?? 50, null);
      enqueue(presets.masks.find(m => m.id === sel.maskId), presets.masks.find(m => m.id === sel.maskId)?.offset?.x ?? 50, presets.masks.find(m => m.id === sel.maskId)?.offset?.y ?? 50, null);

      // accessories: each instance placed relative to anchor + instance.offset
      for (const inst of sel.accessories) {
        const item = presets.accessories.find(a => a.id === inst.id);
        if (!item) continue;
        const attachTo = inst.attachTo || item.defaultAttachTo || 'torso';
        const anchor = computeAnchorPosition(attachTo);
        const finalX = anchor.x + (inst.offset?.x || item.offset?.x || 0);
        const finalY = anchor.y + (inst.offset?.y || item.offset?.y || 0);
        enqueue(item, finalX, finalY, inst);
      }

      // sort by zIndex ascending (draw lower zIndex first)
      drawItems.sort((a,b) => (a.off.zIndex||10) - (b.off.zIndex||10));

      // load all images
      try {
        const loaded = await Promise.all(drawItems.map(d => loadImage(d.item.image)));
        // draw white background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,0,canvas.width,canvas.height);

        for (let i = 0; i < drawItems.length; i++) {
          const d = drawItems[i];
          const img = loaded[i];
          const off = d.off;
          const inst = d.instance;
          const scale = (off.scale || 1) * (canvas.width / stage.clientWidth);
          const drawW = img.naturalWidth * scale;
          const drawH = img.naturalHeight * scale;
          const cx = d.left;
          const cy = d.top;

          ctx.save();
          ctx.translate(cx, cy);
          // mirroring
          const mirror = inst?.mirror ? -1 : 1;
          if (mirror === -1) ctx.scale(-1,1);
          // rotation in radians (from instance if present else off.rotation)
          const rotation = ((inst?.rotation !== undefined) ? inst.rotation : (off.rotation || 0)) * Math.PI / 180;
          if (rotation) ctx.rotate(rotation);
          // draw centered
          ctx.drawImage(img, -drawW/2 * (mirror === -1 ? -1 : 1), -drawH/2, drawW * (mirror === -1 ? -1 : 1), drawH);
          ctx.restore();
        }

        // generate PNG and download
        const url = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = url;
        const safeName = (document.getElementById('name').value || 'wrestler').replace(/[^a-z0-9_\-]/ig,'_');
        a.download = safeName + '.png';
        document.body.appendChild(a);
        a.click();
        a.remove();
      } catch (e) {
        alert('Export failed: ' + e.message);
        console.error(e);
      }
    }

    // Save to server: maintain compatibility by sending accessoryIds
    async function saveWrestler() {
      const name = document.getElementById('name').value.trim();
      if (!name) { alert('Enter a name'); return; }
      const accessoryIds = sel.accessories.map(a => a.id);
      const payload = {
        name,
        notes: '',
        selection: {
          archetypeId: sel.archetypeId,
          attireId: sel.attireId,
          maskId: sel.maskId,
          accessoryIds,
          heightId: sel.heightId,
          bodyTypeId: sel.bodyTypeId,
          skinColorId: sel.skinColorId
        }
      };
      try {
        await api.saveCharacter(payload);
        await loadCharacters();
        alert('Saved ' + name);
      } catch (e) {
        alert('Save failed: ' + e.message);
      }
    }

    // Randomize and clear
    function randomizeSelection() {
      const rand = arr => arr[Math.floor(Math.random() * arr.length)]?.id;
      sel.archetypeId = rand(presets.archetypes);
      sel.attireId = rand(presets.attire);
      sel.maskId = rand(presets.masks);
      sel.heightId = rand(presets.heights);
      sel.bodyTypeId = rand(presets.bodyTypes);
      sel.skinColorId = rand(presets.skinColors);
      // accessories: random 0..3
      sel.accessories = [];
      const accCount = Math.floor(Math.random() * Math.min(4, presets.accessories.length));
      const shuffled = [...presets.accessories].sort(() => Math.random() - 0.5);
      for (let i=0;i<accCount;i++) {
        const it = shuffled[i];
        sel.accessories.push({
          uid: uid(),
          id: it.id,
          attachTo: it.defaultAttachTo || 'torso',
          mirror: Math.random() > 0.5,
          rotation: (Math.random()*60 - 30) | 0,
          offset: { x: it.offset?.x || 0, y: it.offset?.y || 0, scale: it.offset?.scale || 1 }
        });
      }
      renderAccessoryTray(); updateAvatar();
    }

    function clearSelection() {
      sel.archetypeId = presets.archetypes[0]?.id || null;
      sel.attireId = presets.attire[0]?.id || null;
      sel.maskId = presets.masks[0]?.id || null;
      sel.accessories = [];
      sel.heightId = presets.heights[0]?.id || null;
      sel.bodyTypeId = presets.bodyTypes[0]?.id || null;
      sel.skinColorId = presets.skinColors[0]?.id || null;
      renderAccessoryTray(); updateAvatar();
    }

    // load saved characters
    async function loadCharacters() {
      try {
        const chars = await api.listCharacters();
        const out = document.getElementById('charactersList');
        out.innerHTML = '';
        if (!chars.length) { out.innerHTML = '<div class="small">No saved wrestlers</div>'; return; }
        chars.forEach(c => {
          const row = document.createElement('div'); row.style.padding='8px 0'; row.style.borderBottom='1px solid #f3f4f6';
          row.innerHTML = '<strong>' + c.name + '</strong><div class="small">Archetype: ' + (c.selection?.archetypeId || '-') + '</div>';
          const loadBtn = document.createElement('button'); loadBtn.textContent='Load'; loadBtn.style.marginLeft='8px';
          loadBtn.addEventListener('click', () => {
            sel.archetypeId = c.selection?.archetypeId || sel.archetypeId;
            sel.attireId = c.selection?.attireId || sel.attireId;
            sel.maskId = c.selection?.maskId || sel.maskId;
            // load accessoryIds as simple instances (no mirror/rotation); user can edit them
            sel.accessories = (c.selection?.accessoryIds || []).map(id => ({
              uid: uid(), id, attachTo: presets.accessories.find(a => a.id === id)?.defaultAttachTo || 'torso', mirror: false, rotation: 0, offset: { x: presets.accessories.find(a => a.id === id)?.offset?.x || 0, y: presets.accessories.find(a => a.id === id)?.offset?.y || 0, scale: presets.accessories.find(a => a.id === id)?.offset?.scale || 1 }
            }));
            sel.heightId = c.selection?.heightId || sel.heightId;
            sel.bodyTypeId = c.selection?.bodyTypeId || sel.bodyTypeId;
            sel.skinColorId = c.selection?.skinColorId || sel.skinColorId;
            renderAccessoryTray(); updateAvatar();
          });
          row.appendChild(loadBtn);
          out.appendChild(row);
        });
      } catch (e) {
        document.getElementById('charactersList').textContent = 'Failed to load saved wrestlers';
      }
    }

    // initialize UI
    async function init() {
      presets = await api.getPresets();

      // Render thumbs into grids
      const mapping = [
        ['archetypes','archetypes'], ['attires','attire'], ['masks','masks'],
        ['accessories','accessories'], ['heights','heights'], ['bodyTypes','bodyTypes'],
        ['skinColors','skinColors']
      ];
      for (const [elId, key] of mapping) {
        const cont = document.getElementById(elId);
        const list = presets[key];
        if (!cont || !list) continue;
        cont.innerHTML = '';
        list.forEach(item => cont.appendChild(createThumb(item, key)));
      }

      // set defaults
      sel.archetypeId = presets.archetypes[0]?.id || null;
      sel.attireId = presets.attire[0]?.id || null;
      sel.maskId = presets.masks[0]?.id || null;
      sel.heightId = presets.heights[0]?.id || null;
      sel.bodyTypeId = presets.bodyTypes[0]?.id || null;
      sel.skinColorId = presets.skinColors[0]?.id || null;

      document.getElementById('saveBtn').addEventListener('click', saveWrestler);
      document.getElementById('randomBtn').addEventListener('click', randomizeSelection);
      document.getElementById('clearBtn').addEventListener('click', clearSelection);
      document.getElementById('toggleAnchorsBtn').addEventListener('click', () => { anchorsVisible = !anchorsVisible; updateAvatar(); });
      document.getElementById('exportBtn').addEventListener('click', exportToPNG);

      initDropHandlers();
      renderAccessoryTray();
      updateAvatar();
      loadCharacters();
    }

    init().catch(e => { console.error(e); alert('Init failed: ' + e.message); });
  </script>
</body>
</html>
